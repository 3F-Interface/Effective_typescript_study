## 아이템 46 - 타입 선언과 관련된 세 가지 버전 이해하기

### 타입스크립트를 사용할 때 고려해야 할 세 가지

1. 라이브러리의 버전
2. 타입 선언(@types)의 버전
3. 타입스크립트의 버전

### 라이브러리 버전이 타입 선언버전보다 최신인 경우

- 라이브러리 업데이트와 관련된 새로운 기능을 사용할 때마다 타입 오류 발생
- 하위 호환성이 깨지는 변경이 있었다면, 타입 체커를 통과해도 런타임에서 오류가 발생할 수 있음

- 해결책
  - 타입 선언도 버전을 업데이트 해 버전을 맞춤
  - 타입 선언의 버전이 준비되지 않은 경우
    - 보강(augmentation) 기법 활용 / 새 함수나 메소드의 타입 정보를 프로젝트 자체에 추가
    - 타입 선언의 업데이트를 직접 작성해 커뮤니티에 기여

### 라이브러리보다 타입 선언의 버전이 최신인 경우

- 라이브러리 버전을 올리거나 타입 선언의 버전을 내림

### 프로젝트에서 사용하는 타입스크립트 버전보다 라이브러리에서 필요로 하는 타입스크립트 버전이 최신인 경우

- 프로젝트의 타입스크립트 버전을 올림
- 라이브러리 타입 선언의 버전을 내림
- `declare module` 선언으로 라이브러리 타입 정보를 없앰

### `@types` 의존성이 중복될 경우

- 중복되는 타입을 업데이트해 버전이 호환되도록 함
  - 해당 방식은 의존성을 만들어 문제를 일으킬 수 있음

### 타입 번들링 방식의 네 가지 문제점

1. 번들된 타입 선언에 보강 기법으로 해결할 수 없는 오류가 있거나, 공개 시점에는 잘 동작했지만 버전이 올라가면서 오류가 발생하는 경우
2. 프로젝트 내의 타입 선언이 다른 라이브러리의 타입 선언에 의존하는 경우
3. 프로젝트의 과거 버전에 있는 타입 선언에 문제가 있는 경우
4. 타입 선언의 패치 업데이트를 자주 하기 어려움

### 의존성을 잘 관리한다면?

- 잘 작성된 타입 선언은 라이브러리를 올바르게 사용하는 방법을 배우는 데 도움이 되며 생산성을 크게 향상시킬 수 있음

### 라이브러리를 만들 때 권장사항

- 타입 선언을 자체적으로 포함하는 것과, 타입 정보만 분리하여 `DefinitelyTyped`에 공개하는 것의 장단점을 비교해보아야 함
- 라이브러리가 타입스크립트로 작성된 경우만 타입 선언을 라이브러리에 포함

## 아이템 47 - 공개 API에 등장하는 모든 타입을 익스포트하기

- 라이브러리 사용자를 위해 명시적으로 모든 타입을 익스포트하는것이 좋음

## 아이템 48 - API 주석에 TSDoc 사용하기

- JSDoc 형태(`/** 주석 */`)로 작성해야, 편집기에서 주석을 툴팁으로 표시해 줌
- `@param`, `@returns` 같은 일반적 규칙을 사용할 수 있음
- 마크다운 사용 가능

## 아이템 49 - 콜백에서 this에 대한 타입 제공하기