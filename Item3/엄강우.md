## Item3

타입스크립트 컴파일러는 2가지의 역할을 합니다.

- 최신 자바스크립트/타입스크립트가 브라우저에서 잘 동작할 수 있도록 구 버전으로 트랜스파일합니다.
- 코드의 타입 오류를 체크합니다.

이 두 가지의 일은 독립적으로 동작하기 때문에 타입 체크와 구 버전의 자바스크립트로의 트랜트파일은 서로에게 영향을 주지 않습니다.

#### 코드 오류가 있는 코드도 컴파일이 가능합니다.

타입 스크립트 코드 오류는 `warning`과 비슷하기 때문에 빌드를 멈추지 않습니다.

> 코드 오류가 있을때 컴파일에 문제가 있다라고 표현하는 것은 적절하지 않은 표현입니다. 타입 체크에 문제가 있다라고 표현하는 것이 올바른 표현입니다.

#### 런타임에는 타입 체크가 불가능합니다.

```tsx
interface Square {
  width: number;
}

interface Rectangle extends Square {
  height: number;
}

type Shape = Square | Rectangle;

function calculateArea(shape: Shape) {
  if (shape instanceof Rectangle) {
    return shape.width * shape.height;
  }
  return shape.width * shape.width;
}
```

`instanceof`체크는 런타임에서 일어나지만 `Rectangle`은 타입이기 때문에 타입 체크에는 아무 소용이 없습니다. 그래서 선택적인 `shape`에 대한 타입체크를 명확하게 하지 위해서는 런타임에 타입 정보를 유지하는 방법이 필요합니다. 

첫번째 방법은 `height`라는 프로퍼티가 존재하는지 체크 해보는 것입니다. 

```tsx
if ('height' in shape) {
  return shape.width * shape.height;
}
```

두 번째 방법은 런타임에 접근 가능한 타입 정보를 명시적으로 저장하는 `태그`기법이 있습니다.

```tsx
interface Square {
  kind: 'sqaure'
  width: number
}

interface Rectangle {
  kind: 'rectangle'
  height: number
  width: number
}

type Shape = Square | Rectangle

function calculateArea(shape: Shape) {
  if (shape.kind === 'rectangle') {
    return shape.width * shape.height
  }
  return shape.width * shape.width
}
```

 물론 타입을 클래스로 만들어서 하는 방법 또한 있습니다.

그리고 타입 predicated를 이용한 방법 또한 있습니다.

```tsx
function isFish(pet: Fish | Bird): pet is Fish {
  return (pet as Fish).swim !== undefined;
}

let pet = getSmallPet();
 
if (isFish(pet)) {
  pet.swim();
} else {
  pet.fly();
}

// 타입스크립트 공식 문서 narrowing 참조
```

#### 타입 연산은 런타임에 영향을 주지 않습니다.

타입 단언인  `as Number`와 같은 연산은 타입 체크에만 이용되며 런타임에는 아무 의미가 없는 코드 입니다. `as Number`와 같은 연산에 의해 런타임 상에서의 결과물 또한 항상 `number`타입을 가질 것이라는 생각을 해서는 안됩니다.

#### 런타임 타입은 선언된 타입과 다를 수 있습니다.

결국 런타임에서는 타입이 제거된 상태의 자바스크립트가 실행 되기 때문에 우리의 예상과 다른 타입을 가지는 변수가 존재할 수 있습니다. 하지만 그런 상황을 언제나 잘 피할 수 있어야합니다.

#### 타입스크립트 타입으로는 함수를 오버로드 할 수 없습니다.

#### 타입스크립트 타입은 런타임 성능에 영향을 주지 않습니다.





