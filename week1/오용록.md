# 1장. 타입스크립트 알아보기

## 아이템 1 타입스크립트와 자바스크립트의 관계 이해하기

### 타입스크립트는 문법적으로도 자바스크립트의 상위 집합입니다

- 자바스크립트 프로그램에 문법 오류가 없다면, 유효한 타입스크립트 프로그램이라고 할 수 있습니다.
- .js 파일에 있는 코드는 이미 타입스크립트라고 할 수 있습니다.
- **이러한 특성은 기존에 존재하는 자바스크립트 코드를 타입스크립트로 마이그레이션 하는 데 엄청난 이점이 됩니다.**
- 모든 자바스크립트는 타입스크립트이지만, 모든 타입스크립트가 자바스크립트는 아닙니다.
- 일부 자바스크립트(그리고 타입스크립트)만이 타입 체크를 통과합니다.

### 타입스크립트 타입 시스템은 전반적으로 자바스크립트의 동작을 모델링합니다

- 자바스크립트에서는 허용되지만 타입스크립트에서는 문제가 되는 경우도 있습니다.
- 타입 체커를 통과하면서 런타임 오류를 발생시키는 코드를 주의해야 합니다.

### 타입스크립트 채택의 여부는 선택

- 타입스크립트의 도움을 받으면 오류가 적은 코드를 작성할 수 있습니다.

## 아이템 2 타입스크립트 설정 이해하기

### 타입스크립트 컴파일러 설정

- tsconfig.json 파일을 사용하는 것이 좋습니다.

### noImplicitAny, strictNullChecks

- 자바스크립트 프로젝트를 타입스크립트로 전환(8장 참고)하는게 아니라면 noImplicitAny, strictNullChecks 설정을 해두는 것이 좋습니다.
- 타입스크립트가 처음이라면 strictNullChecks를 설정하지 않아도 괜찮습니다.

```
// tsconfig.json
{
  "compilerOptions": {
    "noImplicitAny": true,
    "strictNullChecks": true
  }
}
```

## 아이템 3 코드 생성 타입이 관계없음을 이해하기

### 타입스크립트 컴파일러가 하는 두 가지 역할

- 최신 ts/js를 브라우저에서 동작할 수 있게 구버전의 js로 트랜스파일 합니다.
- 코드의 타입 오류를 체크합니다.

### 타입 오류가 있는 코드도 컴파일이 가능합니다

- 타입스크립트 오류는 C나 자바같은 언어들의 경고(warning)와 비슷합니다.
- 코드에 오류가 있더라도 컴파일된 산출물이 나오는 것이 실제로 도움이 됩니다.
- tsconfig.json이나 빌드 도구에 onEmitOnError를 설정하면, 오류가 있을 때 컴파일을 하지 않을 수 있습니다.

### 런타임에는 타입 체크가 불가능합니다

- 자바스크립트로 컴파일되는 과정에서 모든 인터페이스 타입, 타입 구문은 제거됩니다.
- 런타임에 타입정보를 유지하는 방법
  - 속성이 존재하는 지 체크
  - 명시적으로 저장하는 '태그'기법
  - 타입을 class로 만들어 타입(런타임 접근 불가)과 값(런타임 접근 가능)을 둘다 사용하는 기법

### 타입연산은 런타임에 영향을 주지 않습니다

```
// X 런타임에는 아무런 영향을 미치지 못함
function asNumber(val: number | string): number {
  return val as number // 타입 단언문
}
```

```
// O
function asNumber(val: number | string): number {
  return typeof(val) === 'string' ? Number(val) : val;
}
```

### 런타임 타입은 선언된 타입과 다를 수 있습니다

- 선언된 타입이 언제든지 달라질 수 있다는 것을 명심해야 합니다.
- 타입 선언문은 런타임에 제거됩니다.
- 배포된 후(런타임)에 API가 변경되어 response 값의 타입이 변경 될 수도 있습니다.

### 타입스크립트 타입으로는 함수를 오버로드할 수 없습니다

- 타입 수준에서는 가능하지만, 구현체는 결국 하나만 존재합니다.
- 아이템 50에서 더 자세히 다룹니다.

### 타입스크립트 타입은 런타임 성능에 영향을 주지 않습니다

- '런타임' 오버헤드가 없는 대신, '빌드타임' 오버헤드가 있습니다.

## 아이템 4 구조적 타이핑에 익숙해지기

### 덕 타이핑과 구조적 타이핑

- [덕 타이핑과 구조적 타이핑](https://vallista.kr/%EB%8D%95-%ED%83%80%EC%9D%B4%ED%95%91%EA%B3%BC-%EA%B5%AC%EC%A1%B0%EC%A0%81-%ED%83%80%EC%9D%B4%ED%95%91/)
- 덕 타이핑 -> 자바스크립트
- 구조적 타이핑 -> 타입스크립트

### 타입은 '봉인(sealed)' 되어있지 않습니다

- 좋든 싫든 타입은 '열려(open)' 있습니다.
- 선언된 타입에 맞는 값이 존재한다면 오류가 아닙니다.
- {x, y, z} <- {x, y} 호환 가능

## 아이템 5 any 타입 지양하기

### any타입의 사용은 최대한 피해야 합니다

- 타입 안전성이 없습니다.
- 함수 시그니처를 무시해 버립니다.
- 언어 서비스가 적용되지 않습니다.
- 코드 리팩터링 때 버그를 감춥니다.
- 타입 설계를 감춰버립니다.
- 타입 시스템의 신뢰도를 떨어뜨립니다.

### any 다루기

- 5장에서 더 자세히 다룰 예정...

# 2장. 타입스크립트의 타입 시스템

## 아이템 6 편집기를 사용하여 타입 시스템 탐색하기

### 타입스크립트를 설치하면, 두 가지를 실행할 수 있습니다

- 타입스크립트 컴파일러(tsc)
- 단독으로 실행할 수 있는 타입스크립트 서버(tsserver) -> '언어 서비스' 제공

### 언어 서비스

- 코드 자동 완성
- 명세(사양, specification) 검사
- 검색
- 리팩터링

### 타입 선언 파일 찾아보기

- 편집기상에 'Go to Definition' 기능을 활용해 lib.dom.d.ts 살펴보기
- 6장에서 더 자세히 다룰 예정...

## 아이템 7 타입이 값들의 집합이라고 생각하기

### never

- 공집합
- 아무런 값도 할당할 수 없습니다.

### 리터럴(literal)타입

- 한 가지 값만 포함하는 타입
- 타입스크립트에서 유닛(unit)타입이라고도 불립니다.

```
type A = 'A';
type b = 'B';
type Twelve = 12;
```

### 유니온(union)타입

- 값 집합들의 합집합
- 값들을 '|' 로 이어주면 됩니다.

```
type AB = 'A' | 'B';
type AB12 = 'A' | 'B' | 12;
```

- AB12 형식은 AB에 할당 불가 (AB12는 AB의 부분 집합이 아니기 때문)

### 인터섹션 타입

- '&' 연산자는 두 타입의 인터섹션(intersection, 교집합)을 계산합니다.
- 두 타입에 해당하는 값을 모두 갖고 있다면 인터섹션 타입에 속합니다.

### 두 인터페이스의 유니온

```
keyof (A&B) = (keyof A) | (keyof B)
keyof (A|B) = (keyof A) & (keyof B)
```

### 상속

- Child는 Parent의 부분집합

```
interface Vector1D { x: number }
interface Vector2D { x: number, y: number }
interface Vector3D { x: number, y: number, z: number }

// 위 코드의 관계와 같다
interface Vector1D { x: number }
interface Vector2D extends Vector1D { y: number }
interface Vector3D extends Vector2D { z: number }
```

## 아이템 8 타입 공간과 값 공간의 심벌 구분하기

### 한 심벌이 타입인지 값인지는 언뜻 봐서 알 수 없습니다

- 일반적으로 type이나 interface 다음에 나오는 심벌은 타입인 반면, const나 let 선언에 쓰이는 것은 값입니다.
- 타입 선언(:) 또는 타입 단언문(as) 다음에 나오는 심벌은 타입인 반면, '=' 다음에 나오는 모든 것은 값입니다.

### 두 공간 사이에서 다른 의미를 가지는 코드 패턴

|         | 값                                  | 타입                                                                 |
| ------- | ----------------------------------- | -------------------------------------------------------------------- |
| typeof  | 자바스크립트 런타임의 typeof 연산자 | 값을 읽어서 타입스크립트의 타입을 반환                               |
| this    | 자바스크립트의 this                 | 다형성(polymorphic) this, 서브 클래스의 메서드 체인을 구현할 때 유용 |
| & 와 \| | AND와 OR 비트연산                   | 인터섹션과 유니온                                                    |
| const   | 새 변수 선언                        | as const는 리터럴 또는 리터럴 표현식의 추론된 타입을 바꿈            |
| extends | class에서 상속할 때                 | 서브 클래스 또는 서브타입 또는 제너릭 타입의 한정자                  |
| in      | for (key in object)                 | 루프 또는 매핑된 타입                                                |

### 타입스크립트에서의 구조 분해 할당

```
function email(
  {person, subject, body}: {person: Person, subject: string, body: string}
) {
  // ...
}
```

## 아이템 9 타입 단언보다는 타입 선언을 사용하기

### 타입 선언과 타입 단언

- 타입 선언(value: type): 할당되는 값이 해당 인터페이스를 만족하는지 검사
- 타입 단언(value as type): 강제로 타입을 지정했으니 타입 체커가 오류를 무시
- **타입 단언이 꼭 필요한 경우가 아니라면, 안전성 체크도 되는 타입선언을 사용하는 것이 좋습니다.**

### 화살표 함수의 타입 선언

```
const people: Person[] = ['alice', 'bob', 'jan'].map(
  (name): Person => ({ name })
)
```

### 타입 단언이 꼭 필요한 경우

- 타입체커가 추론한 타입보다 여러분이 판단한 타입이 더 정확할 때 필요합니다.
- 타입스크립트는 DOM에 접근할 수 없기 때문에 DOM을 조작하는 경우 타입 단언문을 쓰는 것이 타당합니다.
- '\*!'(접미사 !) 단언문으로 해당 DOM이 null이 아님을 단언하는 경우

## 아이템 10 객체래퍼타입 피하기

### 7가지 기본형

- string, number, boolean, null, undefined, symbol, bigint

### 객체래퍼타입을 지양하고, 기본형 타입을 사용

- 타입스크립트가 제공하는 타입선언은 전부 기본형 타입으로 되어있습니다.
- string은 String에 할당할 수 있지만 String은 string에 할당할 수 없습니다.
