# 아이템 1 - 타입스크립트와 자바스크립트의 관계 이해하기

타입스크립트는 자바스크립트의 상위집합(superset)
'정적' 타입 시스템 - 컴파일 시 변수의 타입을 지정하는 것

### 타입스크립트의 특징

- 자바스크립트의 런타임 동작을 모델링 함
  - 타입 시스템은 런타임에 오류를 발생시킬 코드를 미리 찾아 냄
- 모든 오류를 찾아주지는 않고, 의도와 다르게 동작할 수도 있음
  - 타입 체커를 통과하면서도 런타임 오류를 발생시킬 수 있음

# 아이템 2 - 타입스크립트 설정 이해하기

`tsconfig.json`에서 설정
`tsc --init`으로 설정파일 생성

### 대표적인 설정값

- `noImplicitAny` - 변수들이 미리 정의된 타입을 가져야하는지 여부
- `strictNullCheckes` - `null`과 `undefined`가 모든 타입에서 허용되는지 여부
- `strict`로 엄격한 체크 가능

# 아이템 3 - 코드 생성과 타입이 관계없음을 이해하기

### TS 컴파일러의 역할

- 최신 TS/JS를 구버전 JS로 트랜스파일
- 타입 오류 체크

이 때 두가지는 독립적으로 작동하기 때문에 다음과 같은 경우가 생길 수 있다.

- 타입 오류가 있어도 컴파일이 가능
  - 경고를 해주지만 빌드를 멈추지는 않음
  - 즉, 작성한 TS가 유효한 JS라면 컴파일을 정상적으로 실행
  - 오류가 있을 때 컴파일을 멈추려면 `noEmitOnError` 속성을 추가

- 런타임에는 타입 체크가 불가능
  - 컴파일되는 과정에서 `interface`, `type`, 타입 구문은 제거됨
  - 따라서 타입을 명확하게 하기 위해선 세 가지 방법이 존재함
    - 타입 가드 - 해당 속성이 존재하는지 확인하는 방법으로 구분(`if (type in class)`)
    - 태그 기법 - `type Shape = Square | Rectangle`과 같이 Union으로 엮어 구분
    - 타입을 클래스로 만들어 `interfaceof`로 구분

- 타입 연산은 런타임에 영향을 주지 않음
  - 타입 단언의 예시로 `as number`와 같은 코드는 타입을 number로 변환 시켜주는 역할이 아니므로, `Number()`와 같이 연산을 통해 변환을 수행해야 함

- 런타임 타입은 선언된 타입과 다를 수 있음
  
- 타입으로는 함수를 오버로드 할 수 없음
  - 타입과 런타임 동작이 무관하기 때문에, 함수 오버로딩이 불가능
  - 같은 이름의 다른 두 개의 선언문은 JS로 변환되면서 제거되고, 구현체만 남게됨

- 타입은 런타임 성능에 영향을 주지 않음
  - 타입과 타입 연산자는 JS 변환 시점에 제거되기 때문에, 런타임 성능에 영향을 주지 않음
  - 즉, 정적 타입은 비용이 들지 않음

# 아이템 4 - 구조적 타이핑에 익숙해지기

- 타입의 확장에 열려있기 때문에, 같은 속성명을 가지면 다른 속성이 추가로 있는 타입과의 차이를 잡아낼 수 없음
  
- 구조적 타이핑의 장점
  - 유닛 테스트에 유용함
  - 라이브러리 간의 의존성을 완벽하게 분리할 수 있음
  - 

# 아이템 5 - any 타입 지양하기

- 타입 안정성이 없음
- 함수 시그니처를 무시
- 자동완성, 포매팅 서비스가 제공이 되지 않음
- 타입 체크를 통과하더라도 런타임에 오류가 발생하는 경우 찾기 쉽지 않음
- 타입 설계를 감춰 불분명해짐
- 타입시스템의 신뢰도를 떨어뜨림

# 아이템 6 - 편집기를 사용하여 타입 시스템 탐색하기

