# 아이템 1 - 타입스크립트와 자바스크립트의 관계 이해하기

타입스크립트는 자바스크립트의 상위집합(superset)
'정적' 타입 시스템 - 컴파일 시 변수의 타입을 지정하는 것

### 타입스크립트의 특징

- 자바스크립트의 런타임 동작을 모델링 함
  - 타입 시스템은 런타임에 오류를 발생시킬 코드를 미리 찾아 냄
- 모든 오류를 찾아주지는 않고, 의도와 다르게 동작할 수도 있음
  - 타입 체커를 통과하면서도 런타임 오류를 발생시킬 수 있음

# 아이템 2 - 타입스크립트 설정 이해하기

`tsconfig.json`에서 설정
`tsc --init`으로 설정파일 생성

### 대표적인 설정값

- `noImplicitAny` - 변수들이 미리 정의된 타입을 가져야하는지 여부
- `strictNullCheckes` - `null`과 `undefined`가 모든 타입에서 허용되는지 여부
- `strict`로 엄격한 체크 가능

# 아이템 3 - 코드 생성과 타입이 관계없음을 이해하기

### TS 컴파일러의 역할

- 최신 TS/JS를 구버전 JS로 트랜스파일
- 타입 오류 체크

이 때 두가지는 독립적으로 작동하기 때문에 다음과 같은 경우가 생길 수 있다.

- 타입 오류가 있어도 컴파일이 가능
  - 경고를 해주지만 빌드를 멈추지는 않음
  - 즉, 작성한 TS가 유효한 JS라면 컴파일을 정상적으로 실행
  - 오류가 있을 때 컴파일을 멈추려면 `noEmitOnError` 속성을 추가

- 런타임에는 타입 체크가 불가능
  - 컴파일되는 과정에서 `interface`, `type`, 타입 구문은 제거됨
  - 따라서 타입을 명확하게 하기 위해선 세 가지 방법이 존재함
    - 타입 가드 - 해당 속성이 존재하는지 확인하는 방법으로 구분(`if (type in class)`)
    - 태그 기법 - `type Shape = Square | Rectangle`과 같이 Union으로 엮어 구분
    - 타입을 클래스로 만들어 `interfaceof`로 구분

- 타입 연산은 런타임에 영향을 주지 않음
  - 타입 단언의 예시로 `as number`와 같은 코드는 타입을 number로 변환 시켜주는 역할이 아니므로, `Number()`와 같이 연산을 통해 변환을 수행해야 함

- 런타임 타입은 선언된 타입과 다를 수 있음
  
- 타입으로는 함수를 오버로드 할 수 없음
  - 타입과 런타임 동작이 무관하기 때문에, 함수 오버로딩이 불가능
  - 같은 이름의 다른 두 개의 선언문은 JS로 변환되면서 제거되고, 구현체만 남게됨

- 타입은 런타임 성능에 영향을 주지 않음
  - 타입과 타입 연산자는 JS 변환 시점에 제거되기 때문에, 런타임 성능에 영향을 주지 않음
  - 즉, 정적 타입은 비용이 들지 않음

# 아이템 4 - 구조적 타이핑에 익숙해지기

### 구조적 타이핑이란?

- 멤버만으로 타입을 관계시키는 방법
- 즉, 구조가 같으면 같은 타입으로 간주함
- 타입의 확장에 열려있기 때문에, 같은 속성명을 가지면 다른 속성이 추가로 있는 타입과의 차이를 잡아낼 수 없음
  
### 구조적 타이핑의 장점
  - 유닛 테스트에 유용함 (비교가 쉬움)
  - 라이브러리 간의 의존성을 완벽하게 분리할 수 있음


# 아이템 5 - any 타입 지양하기

- 타입 안정성이 없음
- 함수 시그니처를 무시
- 자동완성, 포매팅 서비스가 제공이 되지 않음
- 타입 체크를 통과하더라도 런타임에 오류가 발생하는 경우 찾기 쉽지 않음
- 타입 설계를 감춰 불분명해짐
- 타입시스템의 신뢰도를 떨어뜨림

# 아이템 6 - 편집기를 사용하여 타입 시스템 탐색하기

- 타입 선언 파일 찾아보며 동작 확인

# 아이템 7 - 타입이 값들의 집합이라고 생각하기

- 타입 - 할당 가능한 값들의 집합

### 집합의 크기

- `never` - 아무 값도 포함하지 않는 공집합
- 유닛(Unit), 리터럴 - `type A = 'a'`와 같이 한 가지 값만 포함
- 유니온(Union) - 여러개를 묶기 위해 파이프(`|`) 사용
- 타입 지정 - `string`, `number`와 같이 무한대 범위를 지정

### 교집합(&, intersection)

- 속성에 대해 합집합처럼 생각하면 된다

```ts
interface A { a: string }
interface B { b: string }
type C = A & B
const obj: C {
  a: 'a',
  b: 'b'
} // 정상
```

### 서브타입(subtype)

`interface A extends B`

# 아이템 9 - 타입 단언보다는 타입 선언을 사용하기

- 변수에 값을 할당하고 타입을 부여하는 두 가지 방법>ㅁ

```ts
interface Person { name: string }

const alice: Person = { name: 'Alice' } // 타입 선언
const bob = { name: 'bob' } as Person // 타입 단언
```

- 함수 호출 체이닝이 연속되는 곳에서는 시작에서부터 명명된 타입을 가져야 함
- 타입 단언은 꼭 필요한 경우에 사용해야 함(DOM)
- `!`를 통해 `null`이 아님을 단언할 수 있음 (ex: `document.getElementById('foo)!`)
- `as unknown`을 통해 서로의 서브타입이 아닐 때 변환 가능(지양)

# 아이템 10 - 객체 래퍼 타입 피하기

- 객체 래퍼 타입은 지양하고, 기본형 타입을 사용해야 함
  - `String > string`, `Number > number` 등..

