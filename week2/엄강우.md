## Item11 : 잉여 속성 체크의 한계 인지하기

```tsx
interface Room {
    numDoors: number;
    ceilingHeightFt: number;
}

const r : Room = {
    numDoors: 1,
    ceilingHeightFt: 10,
    elephant: 'present',
} // elephant가 없다고 에러가 발생
```

구조적 타이핑에 의해 오류가 나지 않아야합니다. 타입의 모든 프로퍼티는 가지고 있기 때문에.

```tsx
const obj = {
    numDoors: 1,
    ceilingHeightFt: 10,
    elephant: 'present',
}
const r : Room = obj;
```

이는 정상 동작합니다. obj 타입은 Room타입의 부분 집합이므로. Room에 할당 가능합니다.

첫번째 예제와 두번째 예제의 차이점은 무엇이었을까요?

일단 첫번째 예제에서의 오류는 `잉여 속성 체크`라는 과정에서 생긴 에러입니다. 하지만 두번째 예제를 통해서 구현에 따라 동작하지 않을 수도 있다라는 것을 볼 수 있었습니다.

여기서 생기는 의문을 줄이기 위해서는 `잉여 속성 체크`와 `할당가능 검사`는 별도의 과정임을 알아야합니다.

첫번째 예제 처럼 객체 리터럴로 객체를 생성할 때는 `잉여 속성 체크`가 활성화 됩니다. `엄격한 객체 리터럴 체크`와 같이 불리기도 합니다. 그리고 두번째 예제들 처럼 객체리터럴이 아닐때는 `잉여 속성 체크`는 하지 않고 `할당 가능 검사`만 하게 되어서 에러가 발생하지 않게 됩니다. 타입 단언을 사용하면 후자와 비슷하게 동작하기 때문에 사용을 지양하는 것입니다.

## Item12 : 함수표현식에 타입 적용하기

```tsx
type DiceRollFn = (sides: number) => number
const rollDice: DiceRollFn = sides => {머시기 머시기}
```

타입 스크립트는 함수 표현식을 사용하는게 간편합니다. 함수의 매개변수부터 반환값까지 전체를 함수 타입으로 선언하며 함수 표현식에서 재사용 할 수 있기때문입니다.

위와 같이 함수표현식으로 함수의 타입을 지정하여 `rollDice`에 재사용하는 것을 보면 `rollDice`의 매개변수인 `sides`는 자동적으로 `number`로 유추되는 것을 볼 수 있습니다.

그리고 비슷한 형식의 함수를 이용한다면 타입을 재사용하여 사용할 수 있다는 점도 있습니다.

함수의 매개변수에 타입을 선언하기 보다는 함수 표현식 전체 타입을 정의하는 것이 코드도 간결하고 안전합니다. 다른 함수의 시그니처와 동일한 타입을 가지는 새 함수를 작성하거나, 동일한 타입 시그니처를 가지는 여러개의 함수를 작성할때 반복해서 작정하지 말고 함수 전체의 타입 선언을 적용해야 합니다.

