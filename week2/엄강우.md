## Item11 : 잉여 속성 체크의 한계 인지하기

```tsx
interface Room {
    numDoors: number;
    ceilingHeightFt: number;
}

const r : Room = {
    numDoors: 1,
    ceilingHeightFt: 10,
    elephant: 'present',
} // elephant가 없다고 에러가 발생
```

구조적 타이핑에 의해 오류가 나지 않아야합니다. 타입의 모든 프로퍼티는 가지고 있기 때문에.

```tsx
const obj = {
    numDoors: 1,
    ceilingHeightFt: 10,
    elephant: 'present',
}
const r : Room = obj;
```

이는 정상 동작합니다. obj 타입은 Room타입의 부분 집합이므로. Room에 할당 가능합니다.

첫번째 예제와 두번째 예제의 차이점은 무엇이었을까요?

일단 첫번째 예제에서의 오류는 `잉여 속성 체크`라는 과정에서 생긴 에러입니다. 하지만 두번째 예제를 통해서 구현에 따라 동작하지 않을 수도 있다라는 것을 볼 수 있었습니다.

여기서 생기는 의문을 줄이기 위해서는 `잉여 속성 체크`와 `할당가능 검사`는 별도의 과정임을 알아야합니다.

첫번째 예제 처럼 객체 리터럴로 객체를 생성할 때는 `잉여 속성 체크`가 활성화 됩니다. `엄격한 객체 리터럴 체크`와 같이 불리기도 합니다. 그리고 두번째 예제들 처럼 객체리터럴이 아닐때는 `잉여 속성 체크`는 하지 않고 `할당 가능 검사`만 하게 되어서 에러가 발생하지 않게 됩니다. 타입 단언을 사용하면 후자와 비슷하게 동작하기 때문에 사용을 지양하는 것입니다.